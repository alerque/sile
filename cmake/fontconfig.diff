diff --git a/CMakeLists.txt b/CMakeLists.txt
new file mode 100644
index 0000000..fc039c4
--- /dev/null
+++ b/CMakeLists.txt
@@ -0,0 +1,60 @@
+cmake_minimum_required(VERSION 2.8)
+project(fontconfig)
+
+include(ExternalProject)
+ExternalProject_Add(gperf
+    URL http://gnuwin32.sourceforge.net/downlinks/gperf-bin-zip.php
+    URL_MD5 f67a2271f68894eeaa1984221d5ef5e5
+    CONFIGURE_COMMAND ""
+    BUILD_COMMAND ""
+    INSTALL_COMMAND "")
+
+ExternalProject_Get_Property(gperf SOURCE_DIR)
+set(GPERF "${SOURCE_DIR}/bin/gperf.exe")
+
+list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_LIST_DIR}/cmake")
+find_package(expat REQUIRED)
+find_package(freetype REQUIRED)
+find_package(iconv REQUIRED)
+
+include_directories("${PROJECT_SOURCE_DIR}")
+include_directories("${PROJECT_SOURCE_DIR}/src")
+include_directories("${PROJECT_SOURCE_DIR}/win32")
+include_directories("${PROJECT_BINARY_DIR}")
+include_directories("${PROJECT_BINARY_DIR}/src")
+include_directories("${EXPAT_INCLUDE_DIRS}")
+include_directories("${FREETYPE_INCLUDE_DIRS}")
+include_directories("${ICONV_INCLUDE_DIR}")
+
+add_definitions(-DFLEXIBLE_ARRAY_MEMBER=1)
+add_definitions(-DALIGNOF_DOUBLE=8)
+add_definitions(-DPATH_MAX=2048)
+add_definitions(-Dmode_t=int)
+add_definitions(-DFC_GPERF_SIZE_T=size_t)
+add_definitions(-DHAVE_RAND=1 -DHAVE_STDINT_H=1 -DHAVE_SYS_TYPES_H=1 -DHAVE_SYS_STAT_H=1 -DHAVE_FCNTL_H=1 -DHAVE_UNISTD_H=1 -DHAVE__MKTEMP_S=1 -DHAVE_DIRENT_H=1 -DHAVE_GETOPT=1 -DHAVE_GETOPT_LONG=1)
+add_definitions(-DSIZEOF_VOID_P=${CMAKE_SIZEOF_VOID_P})
+add_definitions(-D_WIN32 -D_CRT_SECURE_NO_WARNINGS -D_CRT_NONSTDC_NO_WARNINGS)
+add_definitions(-DHAVE_ICONV=1)
+
+add_definitions(-DFC_DEFAULT_FONTS="WINDOWSFONTDIR")
+add_definitions(-DFC_CACHEDIR="LOCAL_APPDATA_FONTCONFIG_CACHE")
+add_definitions(-DFONTCONFIG_PATH="")
+add_definitions(-DFC_TEMPLATEDIR="")
+add_definitions("-DFcPublic=__declspec(dllexport)")
+
+add_subdirectory(fc-case)
+add_subdirectory(fc-lang)
+add_subdirectory(src)
+add_subdirectory(fc-cache)
+add_subdirectory(fc-cat)
+add_subdirectory(fc-conflist)
+add_subdirectory(fc-list)
+add_subdirectory(fc-match)
+add_subdirectory(fc-pattern)
+add_subdirectory(fc-query)
+add_subdirectory(fc-scan)
+add_subdirectory(fc-validate)
+
+install(DIRECTORY fontconfig/
+    DESTINATION include/fontconfig
+    FILES_MATCHING PATTERN "*.h")
\ No newline at end of file
diff --git a/cmake/FindIconv.cmake b/cmake/FindIconv.cmake
new file mode 100644
index 0000000..24cdae3
--- /dev/null
+++ b/cmake/FindIconv.cmake
@@ -0,0 +1,57 @@
+# - Try to find Iconv 
+# Once done this will define 
+# 
+#  ICONV_FOUND - system has Iconv 
+#  ICONV_INCLUDE_DIR - the Iconv include directory 
+#  ICONV_LIBRARIES - Link these to use Iconv 
+#  ICONV_SECOND_ARGUMENT_IS_CONST - the second argument for iconv() is const
+# 
+include(CheckCXXSourceCompiles)
+
+IF (ICONV_INCLUDE_DIR AND ICONV_LIBRARIES)
+  # Already in cache, be silent
+  SET(ICONV_FIND_QUIETLY TRUE)
+ENDIF (ICONV_INCLUDE_DIR AND ICONV_LIBRARIES)
+
+FIND_PATH(ICONV_INCLUDE_DIR iconv.h) 
+ 
+FIND_LIBRARY(ICONV_LIBRARIES NAMES iconv libiconv libiconv-2 c)
+ 
+IF(ICONV_INCLUDE_DIR AND ICONV_LIBRARIES) 
+   SET(ICONV_FOUND TRUE) 
+ENDIF(ICONV_INCLUDE_DIR AND ICONV_LIBRARIES) 
+
+set(CMAKE_REQUIRED_INCLUDES ${ICONV_INCLUDE_DIR})
+set(CMAKE_REQUIRED_LIBRARIES ${ICONV_LIBRARIES})
+IF(ICONV_FOUND)
+  check_cxx_source_compiles("
+  #include <iconv.h>
+  int main(){
+    iconv_t conv = 0;
+    const char* in = 0;
+    size_t ilen = 0;
+    char* out = 0;
+    size_t olen = 0;
+    iconv(conv, &in, &ilen, &out, &olen);
+    return 0;
+  }
+" ICONV_SECOND_ARGUMENT_IS_CONST )
+ENDIF(ICONV_FOUND)
+set(CMAKE_REQUIRED_INCLUDES)
+set(CMAKE_REQUIRED_LIBRARIES)
+
+IF(ICONV_FOUND) 
+  IF(NOT ICONV_FIND_QUIETLY) 
+    MESSAGE(STATUS "Found Iconv: ${ICONV_LIBRARIES}") 
+  ENDIF(NOT ICONV_FIND_QUIETLY) 
+ELSE(ICONV_FOUND) 
+  IF(Iconv_FIND_REQUIRED) 
+    MESSAGE(FATAL_ERROR "Could not find Iconv") 
+  ENDIF(Iconv_FIND_REQUIRED) 
+ENDIF(ICONV_FOUND)
+
+MARK_AS_ADVANCED(
+  ICONV_INCLUDE_DIR
+  ICONV_LIBRARIES
+  ICONV_SECOND_ARGUMENT_IS_CONST
+)
diff --git a/fc-cache/CMakeLists.txt b/fc-cache/CMakeLists.txt
new file mode 100644
index 0000000..9ff2141
--- /dev/null
+++ b/fc-cache/CMakeLists.txt
@@ -0,0 +1,3 @@
+add_executable(fc-cache fc-cache.c)
+target_link_libraries(fc-cache fontconfig-static)
+install(TARGETS fc-cache DESTINATION bin)
\ No newline at end of file
diff --git a/fc-case/CMakeLists.txt b/fc-case/CMakeLists.txt
new file mode 100644
index 0000000..e24c1da
--- /dev/null
+++ b/fc-case/CMakeLists.txt
@@ -0,0 +1,9 @@
+file(TO_NATIVE_PATH "${CMAKE_CURRENT_SOURCE_DIR}" CMAKE_CURRENT_SOURCE_DIR_NATIVE)
+
+add_executable(fc-case fc-case.c)
+
+add_custom_command(TARGET fc-case
+    POST_BUILD
+    COMMAND "$<TARGET_FILE:fc-case>"
+    ARGS "${CMAKE_CURRENT_SOURCE_DIR_NATIVE}\\CaseFolding.txt" < "${CMAKE_CURRENT_SOURCE_DIR_NATIVE}\\fccase.tmpl.h" > fccase.h
+    BYPRODUCTS fccase.h)
\ No newline at end of file
diff --git a/fc-cat/CMakeLists.txt b/fc-cat/CMakeLists.txt
new file mode 100644
index 0000000..4c7867b
--- /dev/null
+++ b/fc-cat/CMakeLists.txt
@@ -0,0 +1,3 @@
+add_executable(fc-cat fc-cat.c)
+target_link_libraries(fc-cat fontconfig-static)
+install(TARGETS fc-cat DESTINATION bin)
\ No newline at end of file
diff --git a/fc-conflist/CMakeLists.txt b/fc-conflist/CMakeLists.txt
new file mode 100644
index 0000000..ddf09c7
--- /dev/null
+++ b/fc-conflist/CMakeLists.txt
@@ -0,0 +1,3 @@
+add_executable(fc-conflist fc-conflist.c)
+target_link_libraries(fc-conflist fontconfig-static)
+install(TARGETS fc-conflist DESTINATION bin)
\ No newline at end of file
diff --git a/fc-lang/CMakeLists.txt b/fc-lang/CMakeLists.txt
new file mode 100644
index 0000000..00e110b
--- /dev/null
+++ b/fc-lang/CMakeLists.txt
@@ -0,0 +1,258 @@
+file(TO_NATIVE_PATH "${CMAKE_CURRENT_SOURCE_DIR}" CMAKE_CURRENT_SOURCE_DIR_NATIVE)
+
+add_executable(fc-lang fc-lang.c)
+add_dependencies(fc-lang fc-case)
+
+set(ORTH
+    aa.orth
+    ab.orth
+    af.orth
+    am.orth
+    ar.orth
+    as.orth
+    ast.orth
+    av.orth
+    ay.orth
+    az_az.orth
+    az_ir.orth
+    ba.orth
+    bm.orth
+    be.orth
+    bg.orth
+    bh.orth
+    bho.orth
+    bi.orth
+    bin.orth
+    bn.orth
+    bo.orth
+    br.orth
+    bs.orth
+    bua.orth
+    ca.orth
+    ce.orth
+    ch.orth
+    chm.orth
+    chr.orth
+    co.orth
+    cs.orth
+    cu.orth
+    cv.orth
+    cy.orth
+    da.orth
+    de.orth
+    dz.orth
+    el.orth
+    en.orth
+    eo.orth
+    es.orth
+    et.orth
+    eu.orth
+    fa.orth
+    fi.orth
+    fj.orth
+    fo.orth
+    fr.orth
+    ff.orth
+    fur.orth
+    fy.orth
+    ga.orth
+    gd.orth
+    gez.orth
+    gl.orth
+    gn.orth
+    gu.orth
+    gv.orth
+    ha.orth
+    haw.orth
+    he.orth
+    hi.orth
+    ho.orth
+    hr.orth
+    hu.orth
+    hy.orth
+    ia.orth
+    ig.orth
+    id.orth
+    ie.orth
+    ik.orth
+    io.orth
+    is.orth
+    it.orth
+    iu.orth
+    ja.orth
+    ka.orth
+    kaa.orth
+    ki.orth
+    kk.orth
+    kl.orth
+    km.orth
+    kn.orth
+    ko.orth
+    kok.orth
+    ks.orth
+    ku_am.orth
+    ku_ir.orth
+    kum.orth
+    kv.orth
+    kw.orth
+    ky.orth
+    la.orth
+    lb.orth
+    lez.orth
+    ln.orth
+    lo.orth
+    lt.orth
+    lv.orth
+    mg.orth
+    mh.orth
+    mi.orth
+    mk.orth
+    ml.orth
+    mn_cn.orth
+    mo.orth
+    mr.orth
+    mt.orth
+    my.orth
+    nb.orth
+    nds.orth
+    ne.orth
+    nl.orth
+    nn.orth
+    no.orth
+    nr.orth
+    nso.orth
+    ny.orth
+    oc.orth
+    om.orth
+    or.orth
+    os.orth
+    pa.orth
+    pl.orth
+    ps_af.orth
+    ps_pk.orth
+    pt.orth
+    rm.orth
+    ro.orth
+    ru.orth
+    sa.orth
+    sah.orth
+    sco.orth
+    se.orth
+    sel.orth
+    sh.orth
+    shs.orth
+    si.orth
+    sk.orth
+    sl.orth
+    sm.orth
+    sma.orth
+    smj.orth
+    smn.orth
+    sms.orth
+    so.orth
+    sq.orth
+    sr.orth
+    ss.orth
+    st.orth
+    sv.orth
+    sw.orth
+    syr.orth
+    ta.orth
+    te.orth
+    tg.orth
+    th.orth
+    ti_er.orth
+    ti_et.orth
+    tig.orth
+    tk.orth
+    tl.orth
+    tn.orth
+    to.orth
+    tr.orth
+    ts.orth
+    tt.orth
+    tw.orth
+    tyv.orth
+    ug.orth
+    uk.orth
+    ur.orth
+    uz.orth
+    ve.orth
+    vi.orth
+    vo.orth
+    vot.orth
+    wa.orth
+    wen.orth
+    wo.orth
+    xh.orth
+    yap.orth
+    yi.orth
+    yo.orth
+    zh_cn.orth
+    zh_hk.orth
+    zh_mo.orth
+    zh_sg.orth
+    zh_tw.orth
+    zu.orth
+    ak.orth
+    an.orth
+    ber_dz.orth
+    ber_ma.orth
+    byn.orth
+    crh.orth
+    csb.orth
+    dv.orth
+    ee.orth
+    fat.orth
+    fil.orth
+    hne.orth
+    hsb.orth
+    ht.orth
+    hz.orth
+    ii.orth
+    jv.orth
+    kab.orth
+    kj.orth
+    kr.orth
+    ku_iq.orth
+    ku_tr.orth
+    kwm.orth
+    lg.orth
+    li.orth
+    mai.orth
+    mn_mn.orth
+    ms.orth
+    na.orth
+    ng.orth
+    nv.orth
+    ota.orth
+    pa_pk.orth
+    pap_an.orth
+    pap_aw.orth
+    qu.orth
+    quz.orth
+    rn.orth
+    rw.orth
+    sc.orth
+    sd.orth
+    sg.orth
+    sid.orth
+    sn.orth
+    su.orth
+    ty.orth
+    wal.orth
+    za.orth
+    lah.orth
+    nqo.orth
+    brx.orth
+    sat.orth
+    doi.orth
+    mni.orth
+    und_zsye.orth
+    und_zmth.orth)
+
+add_custom_command(TARGET fc-lang
+    POST_BUILD
+    COMMAND "$<TARGET_FILE:fc-lang>"
+    ARGS -d "${CMAKE_CURRENT_SOURCE_DIR_NATIVE}" ${ORTH} < "${CMAKE_CURRENT_SOURCE_DIR_NATIVE}\\fclang.tmpl.h" > fclang.h
+    BYPRODUCTS fclang.h)
\ No newline at end of file
diff --git a/fc-list/CMakeLists.txt b/fc-list/CMakeLists.txt
new file mode 100644
index 0000000..f572b9c
--- /dev/null
+++ b/fc-list/CMakeLists.txt
@@ -0,0 +1,3 @@
+add_executable(fc-list fc-list.c)
+target_link_libraries(fc-list fontconfig-static)
+install(TARGETS fc-list DESTINATION bin)
\ No newline at end of file
diff --git a/fc-match/CMakeLists.txt b/fc-match/CMakeLists.txt
new file mode 100644
index 0000000..7d799e5
--- /dev/null
+++ b/fc-match/CMakeLists.txt
@@ -0,0 +1,3 @@
+add_executable(fc-match fc-match.c)
+target_link_libraries(fc-match fontconfig-static)
+install(TARGETS fc-match DESTINATION bin)
\ No newline at end of file
diff --git a/fc-pattern/CMakeLists.txt b/fc-pattern/CMakeLists.txt
new file mode 100644
index 0000000..35e92bb
--- /dev/null
+++ b/fc-pattern/CMakeLists.txt
@@ -0,0 +1,3 @@
+add_executable(fc-pattern fc-pattern.c)
+target_link_libraries(fc-pattern fontconfig-static)
+install(TARGETS fc-pattern DESTINATION bin)
\ No newline at end of file
diff --git a/fc-query/CMakeLists.txt b/fc-query/CMakeLists.txt
new file mode 100644
index 0000000..bfec8d4
--- /dev/null
+++ b/fc-query/CMakeLists.txt
@@ -0,0 +1,3 @@
+add_executable(fc-query fc-query.c)
+target_link_libraries(fc-query fontconfig-static)
+install(TARGETS fc-query DESTINATION bin)
\ No newline at end of file
diff --git a/fc-scan/CMakeLists.txt b/fc-scan/CMakeLists.txt
new file mode 100644
index 0000000..c64f925
--- /dev/null
+++ b/fc-scan/CMakeLists.txt
@@ -0,0 +1,3 @@
+add_executable(fc-scan fc-scan.c)
+target_link_libraries(fc-scan fontconfig-static)
+install(TARGETS fc-scan DESTINATION bin)
\ No newline at end of file
diff --git a/fc-validate/CMakeLists.txt b/fc-validate/CMakeLists.txt
new file mode 100644
index 0000000..f3dc6df
--- /dev/null
+++ b/fc-validate/CMakeLists.txt
@@ -0,0 +1,3 @@
+add_executable(fc-validate fc-validate.c)
+target_link_libraries(fc-validate fontconfig-static)
+install(TARGETS fc-validate DESTINATION bin)
\ No newline at end of file
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
new file mode 100644
index 0000000..426ba64
--- /dev/null
+++ b/src/CMakeLists.txt
@@ -0,0 +1,38 @@
+file(TO_NATIVE_PATH "${PROJECT_SOURCE_DIR}" PROJECT_SOURCE_DIR_NATIVE)
+file(TO_NATIVE_PATH "${CMAKE_CURRENT_BINARY_DIR}" CMAKE_CURRENT_BINARY_DIR_NATIVE)
+file(TO_NATIVE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/fcobjshash.gperf.h" GPERF_SOURCE_FILE_NATIVE)
+
+add_custom_command(OUTPUT fcobjshash.gperf
+    COMMAND ${CMAKE_CXX_COMPILER}
+    ARGS /P /EP "/I${PROJECT_SOURCE_DIR_NATIVE}" "${GPERF_SOURCE_FILE_NATIVE}" /Fifcobjshash.gperf)
+
+add_custom_command(OUTPUT fcobjshash.h
+    COMMAND "${GPERF}"
+    ARGS --pic -m 100 fcobjshash.gperf  --output-file fcobjshash.h
+    MAIN_DEPENDENCY fcobjshash.gperf)
+
+file(GENERATE OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/fcstdint.h"
+    CONTENT "#include <stdint.h>")
+
+file(GENERATE OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/fcftaliastail.h" CONTENT "")
+file(GENERATE OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/fcftalias.h" CONTENT "")
+file(GENERATE OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/fcaliastail.h" CONTENT "")
+
+file(GLOB HDR_FILES "${CMAKE_CURRENT_SOURCE_DIR}/*.h")
+file(GLOB SRC_FILES "${CMAKE_CURRENT_SOURCE_DIR}/*.c")
+add_library(fontconfig-static STATIC ${HDR_FILES} ${SRC_FILES} ${CMAKE_CURRENT_BINARY_DIR}/fcobjshash.h)
+
+if (MSVC)
+file(GLOB WIN_SRCS "${PROJECT_SOURCE_DIR}/win32/*.c")
+target_sources(fontconfig-static PRIVATE ${WIN_SRCS})
+endif()
+
+target_include_directories(fontconfig-static PRIVATE "${EXPAT_INCLUDE_DIRS}" "${FREETYPE_INCLUDE_DIRS}")
+target_include_directories(fontconfig-static PRIVATE "${CMAKE_CURRENT_BINARY_DIR}")
+
+add_dependencies(fontconfig-static fc-lang gperf)
+target_link_libraries(fontconfig-static PUBLIC ${EXPAT_LIBRARIES} ${FREETYPE_LIBRARIES} ${ICONV_LIBRARIES})
+
+target_compile_options(fontconfig-static PRIVATE /wd4267 /wd4047 /wd4018 /wd4244 /wd4311)
+
+install(TARGETS fontconfig-static DESTINATION lib)
\ No newline at end of file
diff --git a/src/fcobjs.h b/src/fcobjs.h
index e3926cc..80af590 100644
--- a/src/fcobjs.h
+++ b/src/fcobjs.h
@@ -22,6 +22,14 @@
  * PERFORMANCE OF THIS SOFTWARE.
  */
 /* DON'T REORDER!  The order is part of the cache signature. */
+#ifndef BEGIN_FC_OBJECT
+#define BEGIN_FC_OBJECT
+#endif
+#ifndef END_FC_OBJECT
+#define END_FC_OBJECT
+#endif
+
+BEGIN_FC_OBJECT
 FC_OBJECT (FAMILY,		FcTypeString,	FcCompareFamily)
 FC_OBJECT (FAMILYLANG,		FcTypeString,	NULL)
 FC_OBJECT (STYLE,		FcTypeString,	FcCompareString)
@@ -72,4 +80,5 @@ FC_OBJECT (COLOR,		FcTypeBool,	FcCompareBool)
 FC_OBJECT (SYMBOL,		FcTypeBool,	FcCompareBool)
 FC_OBJECT (FONT_VARIATIONS,	FcTypeString,	NULL)
 FC_OBJECT (VARIABLE,		FcTypeBool,	FcCompareBool)
-/* ^-------------- Add new objects here. */
+END_FC_OBJECT
+/* ^-------------- Add new objects before END_FC_OBJECT. */
\ No newline at end of file
diff --git a/src/fcobjshash.gperf.h b/src/fcobjshash.gperf.h
index 1765c94..6a17324 100644
--- a/src/fcobjshash.gperf.h
+++ b/src/fcobjshash.gperf.h
@@ -22,9 +22,14 @@
  * PERFORMANCE OF THIS SOFTWARE.
  */
 %{
+#define POUND #
+#define SELF(x) x
+#define PREPROCESS(label) SELF(POUND)##label
+PREPROCESS(if 0)
 CUT_OUT_BEGIN
 #include <fontconfig/fontconfig.h>
 CUT_OUT_END
+PREPROCESS(endif)
 %}
 %struct-type
 %language=ANSI-C
@@ -43,7 +48,8 @@ struct FcObjectTypeInfo {
 	int id;
 };
 
-%%
+#define BEGIN_FC_OBJECT %%
+#define END_FC_OBJECT %%
 #define FC_OBJECT(NAME, Type, Cmp) FC_##NAME, FC_##NAME##_OBJECT
 #include "fcobjs.h"
 #undef FC_OBJECT
diff --git a/src/fcxml.c b/src/fcxml.c
index d154a54..e9e02c9 100644
--- a/src/fcxml.c
+++ b/src/fcxml.c
@@ -1384,6 +1384,7 @@ _get_real_path_from_prefix(FcConfigParse *parse, const FcChar8 *path, const FcCh
 	    if (!FcStrIsAbsoluteFilename (path) && path[0] != '~')
 		FcConfigMessage (parse, FcSevereWarning, "Use of ambiguous path in <%s> element. please add prefix=\"cwd\" if current behavior is desired.", FcElementReverseMap (parse->pstack->element));
 	}
+    }
 	if (parent)
 	{
 	    retval = FcStrBuildFilename (parent, data, NULL);
@@ -1392,7 +1393,6 @@ _get_real_path_from_prefix(FcConfigParse *parse, const FcChar8 *path, const FcCh
 	{
 	    retval = FcStrdup (data);
 	}
-    }
 #endif
 
     return retval;
diff --git a/win32/dirent.h b/win32/dirent.h
new file mode 100644
index 0000000..1c658fa
--- /dev/null
+++ b/win32/dirent.h
@@ -0,0 +1,889 @@
+/*
+ * dirent.h - dirent API for Microsoft Visual Studio
+ *
+ * Copyright (C) 2006-2012 Toni Ronkko
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * ``Software''), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL TONI RONKKO BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ *
+ * Version 1.13, Dec 12 2012, Toni Ronkko
+ * Use traditional 8+3 file name if the name cannot be represented in the
+ * default ANSI code page.  Now compiles again with MSVC 6.0.  Thanks to
+ * Konstantin Khomoutov for testing.
+ *
+ * Version 1.12.1, Oct 1 2012, Toni Ronkko
+ * Bug fix: renamed wide-character DIR structure _wDIR to _WDIR (with
+ * capital W) in order to maintain compatibility with MingW.
+ *
+ * Version 1.12, Sep 30 2012, Toni Ronkko
+ * Define PATH_MAX and NAME_MAX.  Added wide-character variants _wDIR,
+ * _wdirent, _wopendir(), _wreaddir(), _wclosedir() and _wrewinddir().
+ * Thanks to Edgar Buerkle and Jan Nijtmans for ideas and code.
+ *
+ * Do not include windows.h.  This allows dirent.h to be integrated more
+ * easily into programs using winsock.  Thanks to Fernando Azaldegui.
+ *
+ * Version 1.11, Mar 15, 2011, Toni Ronkko
+ * Defined FILE_ATTRIBUTE_DEVICE for MSVC 6.0.
+ *
+ * Version 1.10, Aug 11, 2010, Toni Ronkko
+ * Added d_type and d_namlen fields to dirent structure.  The former is
+ * especially useful for determining whether directory entry represents a
+ * file or a directory.  For more information, see
+ * http://www.delorie.com/gnu/docs/glibc/libc_270.html
+ *
+ * Improved conformance to the standards.  For example, errno is now set
+ * properly on failure and assert() is never used.  Thanks to Peter Brockam
+ * for suggestions.
+ *
+ * Fixed a bug in rewinddir(): when using relative directory names, change
+ * of working directory no longer causes rewinddir() to fail.
+ *
+ * Version 1.9, Dec 15, 2009, John Cunningham
+ * Added rewinddir member function
+ *
+ * Version 1.8, Jan 18, 2008, Toni Ronkko
+ * Using FindFirstFileA and WIN32_FIND_DATAA to avoid converting string
+ * between multi-byte and unicode representations.  This makes the
+ * code simpler and also allows the code to be compiled under MingW.  Thanks
+ * to Azriel Fasten for the suggestion.
+ *
+ * Mar 4, 2007, Toni Ronkko
+ * Bug fix: due to the strncpy_s() function this file only compiled in
+ * Visual Studio 2005.  Using the new string functions only when the
+ * compiler version allows.
+ *
+ * Nov  2, 2006, Toni Ronkko
+ * Major update: removed support for Watcom C, MS-DOS and Turbo C to
+ * simplify the file, updated the code to compile cleanly on Visual
+ * Studio 2005 with both unicode and multi-byte character strings,
+ * removed rewinddir() as it had a bug.
+ *
+ * Aug 20, 2006, Toni Ronkko
+ * Removed all remarks about MSVC 1.0, which is antiqued now.  Simplified
+ * comments by removing SGML tags.
+ *
+ * May 14 2002, Toni Ronkko
+ * Embedded the function definitions directly to the header so that no
+ * source modules need to be included in the Visual Studio project.  Removed
+ * all the dependencies to other projects so that this header file can be
+ * used independently.
+ *
+ * May 28 1998, Toni Ronkko
+ * First version.
+ *****************************************************************************/
+#ifndef DIRENT_H
+#define DIRENT_H
+
+#if !defined(_68K_) && !defined(_MPPC_) && !defined(_X86_) && !defined(_IA64_) && !defined(_AMD64_) && defined(_M_IX86)
+#   define _X86_
+#endif
+#include <stdio.h>
+#include <stdarg.h>
+#include <wtypes.h>
+#include <windef.h>
+#include <winbase.h>
+#include <wchar.h>
+#include <string.h>
+#include <stdlib.h>
+#include <malloc.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <errno.h>
+
+/* Indicates that d_type field is available in dirent structure */
+#define _DIRENT_HAVE_D_TYPE
+
+/* Indicates that d_namlen field is available in dirent structure */
+#define _DIRENT_HAVE_D_NAMLEN
+
+/* Entries missing from MSVC 6.0 */
+#if !defined(FILE_ATTRIBUTE_DEVICE)
+#   define FILE_ATTRIBUTE_DEVICE 0x40
+#endif
+
+/* File type and permission flags for stat() */
+#if !defined(S_IFMT)
+#   define S_IFMT   _S_IFMT                     /* File type mask */
+#endif
+#if !defined(S_IFDIR)
+#   define S_IFDIR  _S_IFDIR                    /* Directory */
+#endif
+#if !defined(S_IFCHR)
+#   define S_IFCHR  _S_IFCHR                    /* Character device */
+#endif
+#if !defined(S_IFFIFO)
+#   define S_IFFIFO _S_IFFIFO                   /* Pipe */
+#endif
+#if !defined(S_IFREG)
+#   define S_IFREG  _S_IFREG                    /* Regular file */
+#endif
+#if !defined(S_IREAD)
+#   define S_IREAD  _S_IREAD                    /* Read permission */
+#endif
+#if !defined(S_IWRITE)
+#   define S_IWRITE _S_IWRITE                   /* Write permission */
+#endif
+#if !defined(S_IEXEC)
+#   define S_IEXEC  _S_IEXEC                    /* Execute permission */
+#endif
+#if !defined(S_IFIFO)
+#   define S_IFIFO _S_IFIFO                     /* Pipe */
+#endif
+#if !defined(S_IFBLK)
+#   define S_IFBLK   0                          /* Block device */
+#endif
+#if !defined(S_IFLNK)
+#   define S_IFLNK   0                          /* Link */
+#endif
+#if !defined(S_IFSOCK)
+#   define S_IFSOCK  0                          /* Socket */
+#endif
+
+#if defined(_MSC_VER)
+#   define S_IRUSR  S_IREAD                     /* Read user */
+#   define S_IWUSR  S_IWRITE                    /* Write user */
+#   define S_IXUSR  0                           /* Execute user */
+#   define S_IRGRP  0                           /* Read group */
+#   define S_IWGRP  0                           /* Write group */
+#   define S_IXGRP  0                           /* Execute group */
+#   define S_IROTH  0                           /* Read others */
+#   define S_IWOTH  0                           /* Write others */
+#   define S_IXOTH  0                           /* Execute others */
+#endif
+
+/* Maximum length of file name */
+#if !defined(PATH_MAX)
+#   define PATH_MAX MAX_PATH
+#endif
+#if !defined(FILENAME_MAX)
+#   define FILENAME_MAX MAX_PATH
+#endif
+#if !defined(NAME_MAX)
+#   define NAME_MAX FILENAME_MAX
+#endif
+
+/* File type flags for d_type */
+#define DT_UNKNOWN  0
+#define DT_REG      S_IFREG
+#define DT_DIR      S_IFDIR
+#define DT_FIFO     S_IFIFO
+#define DT_SOCK     S_IFSOCK
+#define DT_CHR      S_IFCHR
+#define DT_BLK      S_IFBLK
+
+/* Macros for converting between st_mode and d_type */
+#define IFTODT(mode) ((mode) & S_IFMT)
+#define DTTOIF(type) (type)
+
+/*
+ * File type macros.  Note that block devices, sockets and links cannot be
+ * distinguished on Windows and the macros S_ISBLK, S_ISSOCK and S_ISLNK are
+ * only defined for compatibility.  These macros should always return false
+ * on Windows.
+ */
+#define	S_ISFIFO(mode) (((mode) & S_IFMT) == S_IFIFO)
+#define	S_ISDIR(mode)  (((mode) & S_IFMT) == S_IFDIR)
+#define	S_ISREG(mode)  (((mode) & S_IFMT) == S_IFREG)
+#define	S_ISLNK(mode)  (((mode) & S_IFMT) == S_IFLNK)
+#define	S_ISSOCK(mode) (((mode) & S_IFMT) == S_IFSOCK)
+#define	S_ISCHR(mode)  (((mode) & S_IFMT) == S_IFCHR)
+#define	S_ISBLK(mode)  (((mode) & S_IFMT) == S_IFBLK)
+
+/* Return the exact length of d_namlen without zero terminator */
+#define _D_EXACT_NAMLEN(p) ((p)->d_namlen)
+
+/* Return number of bytes needed to store d_namlen */
+#define _D_ALLOC_NAMLEN(p) (PATH_MAX + 1)
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* Wide-character version */
+struct _wdirent {
+    long d_ino;                                 /* Always zero */
+    unsigned short d_reclen;                    /* Structure size */
+    size_t d_namlen;                            /* Length of name without \0 */
+    int d_type;                                 /* File type */
+    wchar_t d_name[PATH_MAX + 1];               /* File name */
+};
+typedef struct _wdirent _wdirent;
+
+struct _WDIR {
+    struct _wdirent ent;                        /* Current directory entry */
+    WIN32_FIND_DATAW data;                      /* Private file data */
+    int cached;                                 /* True if data is valid */
+    HANDLE handle;                              /* Win32 search handle */
+    wchar_t *patt;                              /* Initial directory name */
+};
+typedef struct _WDIR _WDIR;
+
+static _WDIR *_wopendir (const wchar_t *dirname);
+static struct _wdirent *_wreaddir (_WDIR *dirp);
+static int _wclosedir (_WDIR *dirp);
+static void _wrewinddir (_WDIR* dirp);
+
+
+/* For compatibility with Symbian */
+#define wdirent _wdirent
+#define WDIR _WDIR
+#define wopendir _wopendir
+#define wreaddir _wreaddir
+#define wclosedir _wclosedir
+#define wrewinddir _wrewinddir
+
+
+/* Multi-byte character versions */
+struct dirent {
+    long d_ino;                                 /* Always zero */
+    unsigned short d_reclen;                    /* Structure size */
+    size_t d_namlen;                            /* Length of name without \0 */
+    int d_type;                                 /* File type */
+    char d_name[PATH_MAX + 1];                  /* File name */
+};
+typedef struct dirent dirent;
+
+struct DIR {
+    struct dirent ent;
+    struct _WDIR *wdirp;
+};
+typedef struct DIR DIR;
+
+static DIR *opendir (const char *dirname);
+static struct dirent *readdir (DIR *dirp);
+static int closedir (DIR *dirp);
+static void rewinddir (DIR* dirp);
+
+
+/* Internal utility functions */
+static WIN32_FIND_DATAW *dirent_first (_WDIR *dirp);
+static WIN32_FIND_DATAW *dirent_next (_WDIR *dirp);
+
+static int dirent_mbstowcs_s(
+    size_t *pReturnValue,
+    wchar_t *wcstr,
+    size_t sizeInWords,
+    const char *mbstr,
+    size_t count);
+
+static int dirent_wcstombs_s(
+    size_t *pReturnValue,
+    char *mbstr,
+    size_t sizeInBytes,
+    const wchar_t *wcstr,
+    size_t count);
+
+static void dirent_set_errno (int error);
+
+/*
+ * Open directory stream DIRNAME for read and return a pointer to the
+ * internal working area that is used to retrieve individual directory
+ * entries.
+ */
+static _WDIR*
+_wopendir(
+    const wchar_t *dirname)
+{
+    _WDIR *dirp = NULL;
+    int error;
+
+    /* Must have directory name */
+    if (dirname == NULL  ||  dirname[0] == '\0') {
+        dirent_set_errno (ENOENT);
+        return NULL;
+    }
+
+    /* Allocate new _WDIR structure */
+    dirp = (_WDIR*) malloc (sizeof (struct _WDIR));
+    if (dirp != NULL) {
+        DWORD n;
+
+        /* Reset _WDIR structure */
+        dirp->handle = INVALID_HANDLE_VALUE;
+        dirp->patt = NULL;
+        dirp->cached = 0;
+
+        /* Compute the length of full path plus zero terminator */
+        n = GetFullPathNameW (dirname, 0, NULL, NULL);
+
+        /* Allocate room for absolute directory name and search pattern */
+        dirp->patt = (wchar_t*) malloc (sizeof (wchar_t) * n + 16);
+        if (dirp->patt) {
+
+            /*
+             * Convert relative directory name to an absolute one.  This
+             * allows rewinddir() to function correctly even when current
+             * working directory is changed between opendir() and rewinddir().
+             */
+            n = GetFullPathNameW (dirname, n, dirp->patt, NULL);
+            if (n > 0) {
+                wchar_t *p;
+
+                /* Append search pattern \* to the directory name */
+                p = dirp->patt + n;
+                if (dirp->patt < p) {
+                    switch (p[-1]) {
+                    case '\\':
+                    case '/':
+                    case ':':
+                        /* Directory ends in path separator, e.g. c:\temp\ */
+                        /*NOP*/;
+                        break;
+
+                    default:
+                        /* Directory name doesn't end in path separator */
+                        *p++ = '\\';
+                    }
+                }
+                *p++ = '*';
+                *p = '\0';
+
+                /* Open directory stream and retrieve the first entry */
+                if (dirent_first (dirp)) {
+                    /* Directory stream opened successfully */
+                    error = 0;
+                } else {
+                    /* Cannot retrieve first entry */
+                    error = 1;
+                    dirent_set_errno (ENOENT);
+                }
+
+            } else {
+                /* Cannot retrieve full path name */
+                dirent_set_errno (ENOENT);
+                error = 1;
+            }
+
+        } else {
+            /* Cannot allocate memory for search pattern */
+            error = 1;
+        }
+
+    } else {
+        /* Cannot allocate _WDIR structure */
+        error = 1;
+    }
+
+    /* Clean up in case of error */
+    if (error  &&  dirp) {
+        _wclosedir (dirp);
+        dirp = NULL;
+    }
+
+    return dirp;
+}
+
+/*
+ * Read next directory entry.  The directory entry is returned in dirent
+ * structure in the d_name field.  Individual directory entries returned by
+ * this function include regular files, sub-directories, pseudo-directories
+ * "." and ".." as well as volume labels, hidden files and system files.
+ */
+static struct _wdirent*
+_wreaddir(
+    _WDIR *dirp)
+{
+    WIN32_FIND_DATAW *datap;
+    struct _wdirent *entp;
+
+    /* Read next directory entry */
+    datap = dirent_next (dirp);
+    if (datap) {
+        size_t n;
+        DWORD attr;
+
+        /* Pointer to directory entry to return */
+        entp = &dirp->ent;
+
+        /*
+         * Copy file name as wide-character string.  If the file name is too
+         * long to fit in to the destination buffer, then truncate file name
+         * to PATH_MAX characters and zero-terminate the buffer.
+         */
+        n = 0;
+        while (n < PATH_MAX  &&  datap->cFileName[n] != 0) {
+            entp->d_name[n] = datap->cFileName[n];
+            n++;
+        }
+        dirp->ent.d_name[n] = 0;
+
+        /* Length of file name excluding zero terminator */
+        entp->d_namlen = n;
+
+        /* File type */
+        attr = datap->dwFileAttributes;
+        if ((attr & FILE_ATTRIBUTE_DEVICE) != 0) {
+            entp->d_type = DT_CHR;
+        } else if ((attr & FILE_ATTRIBUTE_DIRECTORY) != 0) {
+            entp->d_type = DT_DIR;
+        } else {
+            entp->d_type = DT_REG;
+        }
+
+        /* Reset dummy fields */
+        entp->d_ino = 0;
+        entp->d_reclen = sizeof (struct _wdirent);
+
+    } else {
+
+        /* Last directory entry read */
+        entp = NULL;
+
+    }
+
+    return entp;
+}
+
+/*
+ * Close directory stream opened by opendir() function.  This invalidates the
+ * DIR structure as well as any directory entry read previously by
+ * _wreaddir().
+ */
+static int
+_wclosedir(
+    _WDIR *dirp)
+{
+    int ok;
+    if (dirp) {
+
+        /* Release search handle */
+        if (dirp->handle != INVALID_HANDLE_VALUE) {
+            FindClose (dirp->handle);
+            dirp->handle = INVALID_HANDLE_VALUE;
+        }
+
+        /* Release search pattern */
+        if (dirp->patt) {
+            free (dirp->patt);
+            dirp->patt = NULL;
+        }
+
+        /* Release directory structure */
+        free (dirp);
+        ok = /*success*/0;
+
+    } else {
+        /* Invalid directory stream */
+        dirent_set_errno (EBADF);
+        ok = /*failure*/-1;
+    }
+    return ok;
+}
+
+/*
+ * Rewind directory stream such that _wreaddir() returns the very first
+ * file name again.
+ */
+static void
+_wrewinddir(
+    _WDIR* dirp)
+{
+    if (dirp) {
+        /* Release existing search handle */
+        if (dirp->handle != INVALID_HANDLE_VALUE) {
+            FindClose (dirp->handle);
+        }
+
+        /* Open new search handle */
+        dirent_first (dirp);
+    }
+}
+
+/* Get first directory entry (internal) */
+static WIN32_FIND_DATAW*
+dirent_first(
+    _WDIR *dirp)
+{
+    WIN32_FIND_DATAW *datap;
+
+    /* Open directory and retrieve the first entry */
+    dirp->handle = FindFirstFileW (dirp->patt, &dirp->data);
+    if (dirp->handle != INVALID_HANDLE_VALUE) {
+
+        /* a directory entry is now waiting in memory */
+        datap = &dirp->data;
+        dirp->cached = 1;
+
+    } else {
+
+        /* Failed to re-open directory: no directory entry in memory */
+        dirp->cached = 0;
+        datap = NULL;
+
+    }
+    return datap;
+}
+
+/* Get next directory entry (internal) */
+static WIN32_FIND_DATAW*
+dirent_next(
+    _WDIR *dirp)
+{
+    WIN32_FIND_DATAW *p;
+
+    /* Get next directory entry */
+    if (dirp->cached != 0) {
+
+        /* A valid directory entry already in memory */
+        p = &dirp->data;
+        dirp->cached = 0;
+
+    } else if (dirp->handle != INVALID_HANDLE_VALUE) {
+
+        /* Get the next directory entry from stream */
+        if (FindNextFileW (dirp->handle, &dirp->data) != FALSE) {
+            /* Got a file */
+            p = &dirp->data;
+        } else {
+            /* The very last entry has been processed or an error occured */
+            FindClose (dirp->handle);
+            dirp->handle = INVALID_HANDLE_VALUE;
+            p = NULL;
+        }
+
+    } else {
+
+        /* End of directory stream reached */
+        p = NULL;
+
+    }
+
+    return p;
+}
+
+/*
+ * Open directory stream using plain old C-string.
+ */
+static DIR*
+opendir(
+    const char *dirname)
+{
+    struct DIR *dirp;
+    int error;
+
+    /* Must have directory name */
+    if (dirname == NULL  ||  dirname[0] == '\0') {
+        dirent_set_errno (ENOENT);
+        return NULL;
+    }
+
+    /* Allocate memory for DIR structure */
+    dirp = (DIR*) malloc (sizeof (struct DIR));
+    if (dirp) {
+        wchar_t wname[PATH_MAX + 1];
+        size_t n;
+
+        /* Convert directory name to wide-character string */
+        error = dirent_mbstowcs_s(
+            &n, wname, PATH_MAX + 1, dirname, PATH_MAX);
+        if (!error) {
+
+            /* Open directory stream using wide-character name */
+            dirp->wdirp = _wopendir (wname);
+            if (dirp->wdirp) {
+                /* Directory stream opened */
+                error = 0;
+            } else {
+                /* Failed to open directory stream */
+                error = 1;
+            }
+
+        } else {
+            /*
+             * Cannot convert file name to wide-character string.  This
+             * occurs if the string contains invalid multi-byte sequences or
+             * the output buffer is too small to contain the resulting
+             * string.
+             */
+            error = 1;
+        }
+
+    } else {
+        /* Cannot allocate DIR structure */
+        error = 1;
+    }
+
+    /* Clean up in case of error */
+    if (error  &&  dirp) {
+        free (dirp);
+        dirp = NULL;
+    }
+
+    return dirp;
+}
+
+/*
+ * Read next directory entry.
+ *
+ * When working with text consoles, please note that file names returned by
+ * readdir() are represented in the default ANSI code page while any output to
+ * console is typically formatted on another code page.  Thus, non-ASCII
+ * characters in file names will not usually display correctly on console.  The
+ * problem can be fixed in two ways: (1) change the character set of console
+ * to 1252 using chcp utility and use Lucida Console font, or (2) use
+ * _cprintf function when writing to console.  The _cprinf() will re-encode
+ * ANSI strings to the console code page so many non-ASCII characters will
+ * display correcly.
+ */
+static struct dirent*
+readdir(
+    DIR *dirp)
+{
+    WIN32_FIND_DATAW *datap;
+    struct dirent *entp;
+
+    /* Read next directory entry */
+    datap = dirent_next (dirp->wdirp);
+    if (datap) {
+        size_t n;
+        int error;
+
+        /* Attempt to convert file name to multi-byte string */
+        error = dirent_wcstombs_s(
+            &n, dirp->ent.d_name, MAX_PATH + 1, datap->cFileName, MAX_PATH);
+
+        /*
+         * If the file name cannot be represented by a multi-byte string,
+         * then attempt to use old 8+3 file name.  This allows traditional
+         * Unix-code to access some file names despite of unicode
+         * characters, although file names may seem unfamiliar to the user.
+         *
+         * Be ware that the code below cannot come up with a short file
+         * name unless the file system provides one.  At least
+         * VirtualBox shared folders fail to do this.
+         */
+        if (error  &&  datap->cAlternateFileName[0] != '\0') {
+            error = dirent_wcstombs_s(
+                &n, dirp->ent.d_name, MAX_PATH + 1, datap->cAlternateFileName,
+                sizeof (datap->cAlternateFileName) /
+                    sizeof (datap->cAlternateFileName[0]));
+        }
+
+        if (!error) {
+            DWORD attr;
+
+            /* Initialize directory entry for return */
+            entp = &dirp->ent;
+
+            /* Length of file name excluding zero terminator */
+            entp->d_namlen = n - 1;
+
+            /* File attributes */
+            attr = datap->dwFileAttributes;
+            if ((attr & FILE_ATTRIBUTE_DEVICE) != 0) {
+                entp->d_type = DT_CHR;
+            } else if ((attr & FILE_ATTRIBUTE_DIRECTORY) != 0) {
+                entp->d_type = DT_DIR;
+            } else {
+                entp->d_type = DT_REG;
+            }
+
+            /* Reset dummy fields */
+            entp->d_ino = 0;
+            entp->d_reclen = sizeof (struct dirent);
+
+        } else {
+            /*
+             * Cannot convert file name to multi-byte string so construct
+             * an errornous directory entry and return that.  Note that
+             * we cannot return NULL as that would stop the processing
+             * of directory entries completely.
+             */
+            entp = &dirp->ent;
+            entp->d_name[0] = '?';
+            entp->d_name[1] = '\0';
+            entp->d_namlen = 1;
+            entp->d_type = DT_UNKNOWN;
+            entp->d_ino = 0;
+            entp->d_reclen = 0;
+        }
+
+    } else {
+        /* No more directory entries */
+        entp = NULL;
+    }
+
+    return entp;
+}
+
+/*
+ * Close directory stream.
+ */
+static int
+closedir(
+    DIR *dirp)
+{
+    int ok;
+    if (dirp) {
+
+        /* Close wide-character directory stream */
+        ok = _wclosedir (dirp->wdirp);
+        dirp->wdirp = NULL;
+
+        /* Release multi-byte character version */
+        free (dirp);
+
+    } else {
+
+        /* Invalid directory stream */
+        dirent_set_errno (EBADF);
+        ok = /*failure*/-1;
+
+    }
+    return ok;
+}
+
+/*
+ * Rewind directory stream to beginning.
+ */
+static void
+rewinddir(
+    DIR* dirp)
+{
+    /* Rewind wide-character string directory stream */
+    _wrewinddir (dirp->wdirp);
+}
+
+/* Convert multi-byte string to wide character string */
+static int
+dirent_mbstowcs_s(
+    size_t *pReturnValue,
+    wchar_t *wcstr,
+    size_t sizeInWords,
+    const char *mbstr,
+    size_t count)
+{
+    int error;
+
+#if defined(_MSC_VER)  &&  _MSC_VER >= 1400
+
+    /* Microsoft Visual Studio 2005 or later */
+    error = mbstowcs_s (pReturnValue, wcstr, sizeInWords, mbstr, count);
+
+#else
+
+    /* Older Visual Studio or non-Microsoft compiler */
+    size_t n;
+
+    /* Convert to wide-character string */
+    n = mbstowcs (wcstr, mbstr, count);
+    if (n < sizeInWords) {
+
+        /* Zero-terminate output buffer */
+        if (wcstr) {
+            wcstr[n] = 0;
+        }
+
+        /* Length of resuting multi-byte string WITH zero terminator */
+        if (pReturnValue) {
+            *pReturnValue = n + 1;
+        }
+
+        /* Success */
+        error = 0;
+
+    } else {
+
+        /* Could not convert string */
+        error = 1;
+
+    }
+
+#endif
+
+    return error;
+}
+
+/* Convert wide-character string to multi-byte string */
+static int
+dirent_wcstombs_s(
+    size_t *pReturnValue,
+    char *mbstr,
+    size_t sizeInBytes,
+    const wchar_t *wcstr,
+    size_t count)
+{
+    int error;
+
+#if defined(_MSC_VER)  &&  _MSC_VER >= 1400
+
+    /* Microsoft Visual Studio 2005 or later */
+    error = wcstombs_s (pReturnValue, mbstr, sizeInBytes, wcstr, count);
+
+#else
+
+    /* Older Visual Studio or non-Microsoft compiler */
+    size_t n;
+
+    /* Convert to multi-byte string */
+    n = wcstombs (mbstr, wcstr, count);
+    if (n < sizeInBytes) {
+
+        /* Zero-terminate output buffer */
+        if (mbstr) {
+            mbstr[n] = '\0';
+        }
+
+        /* Lenght of resulting multi-bytes string WITH zero-terminator */
+        if (pReturnValue) {
+            *pReturnValue = n + 1;
+        }
+
+        /* Success */
+        error = 0;
+
+    } else {
+
+        /* Cannot convert string */
+        error = 1;
+
+    }
+
+#endif
+
+    return error;
+}
+
+/* Set errno variable */
+static void
+dirent_set_errno(
+    int error)
+{
+#if defined(_MSC_VER)
+
+    /* Microsoft Visual Studio */
+    _set_errno (error);
+
+#else
+
+    /* Non-Microsoft compiler */
+    errno = error;
+
+#endif
+}
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /*DIRENT_H*/
diff --git a/win32/getopt.c b/win32/getopt.c
new file mode 100644
index 0000000..0ed0dd2
--- /dev/null
+++ b/win32/getopt.c
@@ -0,0 +1,562 @@
+/*	$OpenBSD: getopt_long.c,v 1.23 2007/10/31 12:34:57 chl Exp $	*/
+/*	$NetBSD: getopt_long.c,v 1.15 2002/01/31 22:43:40 tv Exp $	*/
+
+/*
+ * Copyright (c) 2002 Todd C. Miller <Todd.Miller@courtesan.com>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Sponsored in part by the Defense Advanced Research Projects
+ * Agency (DARPA) and Air Force Research Laboratory, Air Force
+ * Materiel Command, USAF, under agreement number F39502-99-1-0512.
+ */
+/*-
+ * Copyright (c) 2000 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Dieter Baron and Thomas Klausner.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+#include <getopt.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <windows.h>
+
+#define	REPLACE_GETOPT		/* use this getopt as the system getopt(3) */
+
+#ifdef REPLACE_GETOPT
+int	opterr = 1;		/* if error message should be printed */
+int	optind = 1;		/* index into parent argv vector */
+int	optopt = '?';		/* character checked for validity */
+#undef	optreset		/* see getopt.h */
+#define	optreset		__mingw_optreset
+int	optreset;		/* reset getopt */
+char    *optarg;		/* argument associated with option */
+#endif
+
+#define PRINT_ERROR	((opterr) && (*options != ':'))
+
+#define FLAG_PERMUTE	0x01	/* permute non-options to the end of argv */
+#define FLAG_ALLARGS	0x02	/* treat non-options as args to option "-1" */
+#define FLAG_LONGONLY	0x04	/* operate as getopt_long_only */
+
+/* return values */
+#define	BADCH		(int)'?'
+#define	BADARG		((*options == ':') ? (int)':' : (int)'?')
+#define	INORDER 	(int)1
+
+#ifndef __CYGWIN__
+#define __progname __argv[0]
+#else
+extern char __declspec(dllimport) *__progname;
+#endif
+
+#ifdef __CYGWIN__
+static char EMSG[] = "";
+#else
+#define	EMSG		""
+#endif
+
+static int getopt_internal(int, char * const *, const char *,
+			   const struct option *, int *, int);
+static int parse_long_options(char * const *, const char *,
+			      const struct option *, int *, int);
+static int gcd(int, int);
+static void permute_args(int, int, int, char * const *);
+
+static char *place = EMSG; /* option letter processing */
+
+/* XXX: set optreset to 1 rather than these two */
+static int nonopt_start = -1; /* first non option argument (for permute) */
+static int nonopt_end = -1;   /* first option after non options (for permute) */
+
+/* Error messages */
+static const char recargchar[] = "option requires an argument -- %c";
+static const char recargstring[] = "option requires an argument -- %s";
+static const char ambig[] = "ambiguous option -- %.*s";
+static const char noarg[] = "option doesn't take an argument -- %.*s";
+static const char illoptchar[] = "unknown option -- %c";
+static const char illoptstring[] = "unknown option -- %s";
+
+static void
+_vwarnx(const char *fmt,va_list ap)
+{
+  (void)fprintf(stderr,"%s: ",__progname);
+  if (fmt != NULL)
+    (void)vfprintf(stderr,fmt,ap);
+  (void)fprintf(stderr,"\n");
+}
+
+static void
+warnx(const char *fmt,...)
+{
+  va_list ap;
+  va_start(ap,fmt);
+  _vwarnx(fmt,ap);
+  va_end(ap);
+}
+
+/*
+ * Compute the greatest common divisor of a and b.
+ */
+static int
+gcd(int a, int b)
+{
+	int c;
+
+	c = a % b;
+	while (c != 0) {
+		a = b;
+		b = c;
+		c = a % b;
+	}
+
+	return (b);
+}
+
+/*
+ * Exchange the block from nonopt_start to nonopt_end with the block
+ * from nonopt_end to opt_end (keeping the same order of arguments
+ * in each block).
+ */
+static void
+permute_args(int panonopt_start, int panonopt_end, int opt_end,
+	char * const *nargv)
+{
+	int cstart, cyclelen, i, j, ncycle, nnonopts, nopts, pos;
+	char *swap;
+
+	/*
+	 * compute lengths of blocks and number and size of cycles
+	 */
+	nnonopts = panonopt_end - panonopt_start;
+	nopts = opt_end - panonopt_end;
+	ncycle = gcd(nnonopts, nopts);
+	cyclelen = (opt_end - panonopt_start) / ncycle;
+
+	for (i = 0; i < ncycle; i++) {
+		cstart = panonopt_end+i;
+		pos = cstart;
+		for (j = 0; j < cyclelen; j++) {
+			if (pos >= panonopt_end)
+				pos -= nnonopts;
+			else
+				pos += nopts;
+			swap = nargv[pos];
+			/* LINTED const cast */
+			((char **) nargv)[pos] = nargv[cstart];
+			/* LINTED const cast */
+			((char **)nargv)[cstart] = swap;
+		}
+	}
+}
+
+/*
+ * parse_long_options --
+ *	Parse long options in argc/argv argument vector.
+ * Returns -1 if short_too is set and the option does not match long_options.
+ */
+static int
+parse_long_options(char * const *nargv, const char *options,
+	const struct option *long_options, int *idx, int short_too)
+{
+	char *current_argv, *has_equal;
+	size_t current_argv_len;
+	int i, ambiguous, match;
+
+#define IDENTICAL_INTERPRETATION(_x, _y)                                \
+	(long_options[(_x)].has_arg == long_options[(_y)].has_arg &&    \
+	 long_options[(_x)].flag == long_options[(_y)].flag &&          \
+	 long_options[(_x)].val == long_options[(_y)].val)
+
+	current_argv = place;
+	match = -1;
+	ambiguous = 0;
+
+	optind++;
+
+	if ((has_equal = strchr(current_argv, '=')) != NULL) {
+		/* argument found (--option=arg) */
+		current_argv_len = has_equal - current_argv;
+		has_equal++;
+	} else
+		current_argv_len = strlen(current_argv);
+
+	for (i = 0; long_options[i].name; i++) {
+		/* find matching long option */
+		if (strncmp(current_argv, long_options[i].name,
+		    current_argv_len))
+			continue;
+
+		if (strlen(long_options[i].name) == current_argv_len) {
+			/* exact match */
+			match = i;
+			ambiguous = 0;
+			break;
+		}
+		/*
+		 * If this is a known short option, don't allow
+		 * a partial match of a single character.
+		 */
+		if (short_too && current_argv_len == 1)
+			continue;
+
+		if (match == -1)	/* partial match */
+			match = i;
+		else if (!IDENTICAL_INTERPRETATION(i, match))
+			ambiguous = 1;
+	}
+	if (ambiguous) {
+		/* ambiguous abbreviation */
+		if (PRINT_ERROR)
+			warnx(ambig, (int)current_argv_len,
+			     current_argv);
+		optopt = 0;
+		return (BADCH);
+	}
+	if (match != -1) {		/* option found */
+		if (long_options[match].has_arg == no_argument
+		    && has_equal) {
+			if (PRINT_ERROR)
+				warnx(noarg, (int)current_argv_len,
+				     current_argv);
+			/*
+			 * XXX: GNU sets optopt to val regardless of flag
+			 */
+			if (long_options[match].flag == NULL)
+				optopt = long_options[match].val;
+			else
+				optopt = 0;
+			return (BADARG);
+		}
+		if (long_options[match].has_arg == required_argument ||
+		    long_options[match].has_arg == optional_argument) {
+			if (has_equal)
+				optarg = has_equal;
+			else if (long_options[match].has_arg ==
+			    required_argument) {
+				/*
+				 * optional argument doesn't use next nargv
+				 */
+				optarg = nargv[optind++];
+			}
+		}
+		if ((long_options[match].has_arg == required_argument)
+		    && (optarg == NULL)) {
+			/*
+			 * Missing argument; leading ':' indicates no error
+			 * should be generated.
+			 */
+			if (PRINT_ERROR)
+				warnx(recargstring,
+				    current_argv);
+			/*
+			 * XXX: GNU sets optopt to val regardless of flag
+			 */
+			if (long_options[match].flag == NULL)
+				optopt = long_options[match].val;
+			else
+				optopt = 0;
+			--optind;
+			return (BADARG);
+		}
+	} else {			/* unknown option */
+		if (short_too) {
+			--optind;
+			return (-1);
+		}
+		if (PRINT_ERROR)
+			warnx(illoptstring, current_argv);
+		optopt = 0;
+		return (BADCH);
+	}
+	if (idx)
+		*idx = match;
+	if (long_options[match].flag) {
+		*long_options[match].flag = long_options[match].val;
+		return (0);
+	} else
+		return (long_options[match].val);
+#undef IDENTICAL_INTERPRETATION
+}
+
+/*
+ * getopt_internal --
+ *	Parse argc/argv argument vector.  Called by user level routines.
+ */
+static int
+getopt_internal(int nargc, char * const *nargv, const char *options,
+	const struct option *long_options, int *idx, int flags)
+{
+	const char *oli;				/* option letter list index */
+	int optchar, short_too;
+	static int posixly_correct = -1;
+
+	if (options == NULL)
+		return (-1);
+
+	/*
+	 * XXX Some GNU programs (like cvs) set optind to 0 instead of
+	 * XXX using optreset.  Work around this braindamage.
+	 */
+	if (optind == 0)
+		optind = optreset = 1;
+
+	/*
+	 * Disable GNU extensions if POSIXLY_CORRECT is set or options
+	 * string begins with a '+'.
+	 *
+	 * CV, 2009-12-14: Check POSIXLY_CORRECT anew if optind == 0 or
+	 *                 optreset != 0 for GNU compatibility.
+	 */
+	if (posixly_correct == -1 || optreset != 0)
+		posixly_correct = (getenv("POSIXLY_CORRECT") != NULL);
+	if (*options == '-')
+		flags |= FLAG_ALLARGS;
+	else if (posixly_correct || *options == '+')
+		flags &= ~FLAG_PERMUTE;
+	if (*options == '+' || *options == '-')
+		options++;
+
+	optarg = NULL;
+	if (optreset)
+		nonopt_start = nonopt_end = -1;
+start:
+	if (optreset || !*place) {		/* update scanning pointer */
+		optreset = 0;
+		if (optind >= nargc) {          /* end of argument vector */
+			place = EMSG;
+			if (nonopt_end != -1) {
+				/* do permutation, if we have to */
+				permute_args(nonopt_start, nonopt_end,
+				    optind, nargv);
+				optind -= nonopt_end - nonopt_start;
+			}
+			else if (nonopt_start != -1) {
+				/*
+				 * If we skipped non-options, set optind
+				 * to the first of them.
+				 */
+				optind = nonopt_start;
+			}
+			nonopt_start = nonopt_end = -1;
+			return (-1);
+		}
+		if (*(place = nargv[optind]) != '-' ||
+		    (place[1] == '\0' && strchr(options, '-') == NULL)) {
+			place = EMSG;		/* found non-option */
+			if (flags & FLAG_ALLARGS) {
+				/*
+				 * GNU extension:
+				 * return non-option as argument to option 1
+				 */
+				optarg = nargv[optind++];
+				return (INORDER);
+			}
+			if (!(flags & FLAG_PERMUTE)) {
+				/*
+				 * If no permutation wanted, stop parsing
+				 * at first non-option.
+				 */
+				return (-1);
+			}
+			/* do permutation */
+			if (nonopt_start == -1)
+				nonopt_start = optind;
+			else if (nonopt_end != -1) {
+				permute_args(nonopt_start, nonopt_end,
+				    optind, nargv);
+				nonopt_start = optind -
+				    (nonopt_end - nonopt_start);
+				nonopt_end = -1;
+			}
+			optind++;
+			/* process next argument */
+			goto start;
+		}
+		if (nonopt_start != -1 && nonopt_end == -1)
+			nonopt_end = optind;
+
+		/*
+		 * If we have "-" do nothing, if "--" we are done.
+		 */
+		if (place[1] != '\0' && *++place == '-' && place[1] == '\0') {
+			optind++;
+			place = EMSG;
+			/*
+			 * We found an option (--), so if we skipped
+			 * non-options, we have to permute.
+			 */
+			if (nonopt_end != -1) {
+				permute_args(nonopt_start, nonopt_end,
+				    optind, nargv);
+				optind -= nonopt_end - nonopt_start;
+			}
+			nonopt_start = nonopt_end = -1;
+			return (-1);
+		}
+	}
+
+	/*
+	 * Check long options if:
+	 *  1) we were passed some
+	 *  2) the arg is not just "-"
+	 *  3) either the arg starts with -- we are getopt_long_only()
+	 */
+	if (long_options != NULL && place != nargv[optind] &&
+	    (*place == '-' || (flags & FLAG_LONGONLY))) {
+		short_too = 0;
+		if (*place == '-')
+			place++;		/* --foo long option */
+		else if (*place != ':' && strchr(options, *place) != NULL)
+			short_too = 1;		/* could be short option too */
+
+		optchar = parse_long_options(nargv, options, long_options,
+		    idx, short_too);
+		if (optchar != -1) {
+			place = EMSG;
+			return (optchar);
+		}
+	}
+
+	if ((optchar = (int)*place++) == (int)':' ||
+	    (optchar == (int)'-' && *place != '\0') ||
+	    (oli = strchr(options, optchar)) == NULL) {
+		/*
+		 * If the user specified "-" and  '-' isn't listed in
+		 * options, return -1 (non-option) as per POSIX.
+		 * Otherwise, it is an unknown option character (or ':').
+		 */
+		if (optchar == (int)'-' && *place == '\0')
+			return (-1);
+		if (!*place)
+			++optind;
+		if (PRINT_ERROR)
+			warnx(illoptchar, optchar);
+		optopt = optchar;
+		return (BADCH);
+	}
+	if (long_options != NULL && optchar == 'W' && oli[1] == ';') {
+		/* -W long-option */
+		if (*place)			/* no space */
+			/* NOTHING */;
+		else if (++optind >= nargc) {	/* no arg */
+			place = EMSG;
+			if (PRINT_ERROR)
+				warnx(recargchar, optchar);
+			optopt = optchar;
+			return (BADARG);
+		} else				/* white space */
+			place = nargv[optind];
+		optchar = parse_long_options(nargv, options, long_options,
+		    idx, 0);
+		place = EMSG;
+		return (optchar);
+	}
+	if (*++oli != ':') {			/* doesn't take argument */
+		if (!*place)
+			++optind;
+	} else {				/* takes (optional) argument */
+		optarg = NULL;
+		if (*place)			/* no white space */
+			optarg = place;
+		else if (oli[1] != ':') {	/* arg not optional */
+			if (++optind >= nargc) {	/* no arg */
+				place = EMSG;
+				if (PRINT_ERROR)
+					warnx(recargchar, optchar);
+				optopt = optchar;
+				return (BADARG);
+			} else
+				optarg = nargv[optind];
+		}
+		place = EMSG;
+		++optind;
+	}
+	/* dump back option letter */
+	return (optchar);
+}
+
+#ifdef REPLACE_GETOPT
+/*
+ * getopt --
+ *	Parse argc/argv argument vector.
+ *
+ * [eventually this will replace the BSD getopt]
+ */
+int
+getopt(int nargc, char * const *nargv, const char *options)
+{
+
+	/*
+	 * We don't pass FLAG_PERMUTE to getopt_internal() since
+	 * the BSD getopt(3) (unlike GNU) has never done this.
+	 *
+	 * Furthermore, since many privileged programs call getopt()
+	 * before dropping privileges it makes sense to keep things
+	 * as simple (and bug-free) as possible.
+	 */
+	return (getopt_internal(nargc, nargv, options, NULL, NULL, 0));
+}
+#endif /* REPLACE_GETOPT */
+
+/*
+ * getopt_long --
+ *	Parse argc/argv argument vector.
+ */
+int
+getopt_long(int nargc, char * const *nargv, const char *options,
+    const struct option *long_options, int *idx)
+{
+
+	return (getopt_internal(nargc, nargv, options, long_options, idx,
+	    FLAG_PERMUTE));
+}
+
+/*
+ * getopt_long_only --
+ *	Parse argc/argv argument vector.
+ */
+int
+getopt_long_only(int nargc, char * const *nargv, const char *options,
+    const struct option *long_options, int *idx)
+{
+
+	return (getopt_internal(nargc, nargv, options, long_options, idx,
+	    FLAG_PERMUTE|FLAG_LONGONLY));
+}
diff --git a/win32/getopt.h b/win32/getopt.h
new file mode 100644
index 0000000..44a05fc
--- /dev/null
+++ b/win32/getopt.h
@@ -0,0 +1,105 @@
+#ifndef __GETOPT_H__
+/**
+ * DISCLAIMER
+ * This file has no copyright assigned and is placed in the Public Domain.
+ * This file is a part of the w64 mingw-runtime package.
+ *
+ * The w64 mingw-runtime package and its code is distributed in the hope that it
+ * will be useful but WITHOUT ANY WARRANTY.  ALL WARRANTIES, EXPRESSED OR
+ * IMPLIED ARE HEREBY DISCLAIMED.  This includes but is not limited to
+ * warranties of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#define __GETOPT_H__
+
+/* All the headers include this file. */
+#include <crtdefs.h>
+
+#if defined( WINGETOPT_SHARED_LIB )
+# if defined( BUILDING_WINGETOPT_DLL )
+#  define WINGETOPT_API __declspec(dllexport)
+# else
+#  define WINGETOPT_API __declspec(dllimport)
+# endif
+#else
+# define WINGETOPT_API
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+WINGETOPT_API extern int optind;		/* index of first non-option in argv      */
+WINGETOPT_API extern int optopt;		/* single option character, as parsed     */
+WINGETOPT_API extern int opterr;		/* flag to enable built-in diagnostics... */
+				/* (user may set to zero, to suppress)    */
+
+WINGETOPT_API extern char *optarg;		/* pointer to argument of current option  */
+
+extern int getopt(int nargc, char * const *nargv, const char *options);
+
+#ifdef _BSD_SOURCE
+/*
+ * BSD adds the non-standard `optreset' feature, for reinitialisation
+ * of `getopt' parsing.  We support this feature, for applications which
+ * proclaim their BSD heritage, before including this header; however,
+ * to maintain portability, developers are advised to avoid it.
+ */
+# define optreset  __mingw_optreset
+extern int optreset;
+#endif
+#ifdef __cplusplus
+}
+#endif
+/*
+ * POSIX requires the `getopt' API to be specified in `unistd.h';
+ * thus, `unistd.h' includes this header.  However, we do not want
+ * to expose the `getopt_long' or `getopt_long_only' APIs, when
+ * included in this manner.  Thus, close the standard __GETOPT_H__
+ * declarations block, and open an additional __GETOPT_LONG_H__
+ * specific block, only when *not* __UNISTD_H_SOURCED__, in which
+ * to declare the extended API.
+ */
+#endif /* !defined(__GETOPT_H__) */
+
+#if !defined(__UNISTD_H_SOURCED__) && !defined(__GETOPT_LONG_H__)
+#define __GETOPT_LONG_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct option		/* specification for a long form option...	*/
+{
+  const char *name;		/* option name, without leading hyphens */
+  int         has_arg;		/* does it take an argument?		*/
+  int        *flag;		/* where to save its status, or NULL	*/
+  int         val;		/* its associated status value		*/
+};
+
+enum    		/* permitted values for its `has_arg' field...	*/
+{
+  no_argument = 0,      	/* option never takes an argument	*/
+  required_argument,		/* option always requires an argument	*/
+  optional_argument		/* option may take an argument		*/
+};
+
+extern int getopt_long(int nargc, char * const *nargv, const char *options,
+    const struct option *long_options, int *idx);
+extern int getopt_long_only(int nargc, char * const *nargv, const char *options,
+    const struct option *long_options, int *idx);
+/*
+ * Previous MinGW implementation had...
+ */
+#ifndef HAVE_DECL_GETOPT
+/*
+ * ...for the long form API only; keep this for compatibility.
+ */
+# define HAVE_DECL_GETOPT	1
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !defined(__UNISTD_H_SOURCED__) && !defined(__GETOPT_LONG_H__) */
diff --git a/win32/sys/time.h b/win32/sys/time.h
new file mode 100644
index 0000000..e69de29
diff --git a/win32/unistd.h b/win32/unistd.h
new file mode 100644
index 0000000..1a41d8d
--- /dev/null
+++ b/win32/unistd.h
@@ -0,0 +1,19 @@
+/* stub unistd.h for use for MSVC compilers */
+#pragma once
+#ifndef UNISTD_H
+#define UNISTD_H
+
+#include <io.h>
+
+#ifdef _WIN64
+#define ssize_t __int64
+#else
+#define ssize_t long
+#endif
+
+#define R_OK    4       /* Test for read permission.  */
+#define W_OK    2       /* Test for write permission.  */
+//#define X_OK    1       /* execute permission - unsupported in Windows, using it will crash */
+#define F_OK    0       /* Test for existence.  */
+
+#endif // UNISTD_H
\ No newline at end of file
